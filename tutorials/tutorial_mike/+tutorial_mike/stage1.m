% stage 1
%
%
% Some basic pre-processing before the heavy stuff starts

meegpipe.initialize;

import meegpipe.node.*;
import misc.regexpi_dir;
import mperl.file.spec.catdir;
import mperl.file.find.finddepth_regex_match;
import mperl.join;
import somsds.link2files;
import misc.get_hostname;


%% Analysis parameters

DO_REPORT = true;

PIPE_NAME = 'stage1';

% The (root) location of the output generated by the previous step. In this
% case there has not been any previous processing stage so we just put here
% the directory where the raw .mff files are located
switch lower(get_hostname)
    
    case 'outolintulan',
        INPUT_DIR = '/Volumes/DATA/tutorial_mike/raw';
        
        % The directory where the results of this stage will be placed  
        OUTPUT_DIR = '/Volumes/DATA/tutorial_mike/stage1';
    case 'nin271'
        INPUT_DIR = 'D:\tutorial_mike';
        OUTPUT_DIR = 'D:\tutorial_mike\stage1';
    otherwise
        error('No idea where the data is in this system');
        
end

%% Build pipeline nodes one by one

% Node: data import
myImporter = physioset.import.mff('Precision', 'double');
thisNode = physioset_import.new('Importer', myImporter);
nodeList = {thisNode};

% Node: remove very low frequency trends
thisNode = tfilter.detrend;
nodeList = [nodeList {thisNode}];

% Node: reject bad channels using variance
minVar = @(x) median(x)-10;
maxVar = @(x) median(x) + 20*mad(x);
myCrit = bad_channels.criterion.var.new(...
    'Min',      minVar, ...
    'Max',      maxVar, ...
    'NN',       10, ...
    'Percentile', [0 99]);

thisNode = bad_channels.new('Criterion', myCrit);
nodeList = [nodeList {thisNode}];

% Node: reject bad channels using cross-correlation
minCorr = @(x) median(x) - 10;
maxCorr = Inf;

myCrit =  bad_channels.criterion.xcorr.new(...
    'Min',  minCorr, 'Max', maxCorr, ...
    'NN', 10, 'Percentile', [1 100]);
thisNode = bad_channels.new('Criterion', myCrit);
nodeList = [nodeList {thisNode}];

% Node: reject bad samples
thisNode = bad_samples.new('MADs', 5);
nodeList = [nodeList {thisNode}];

% Node: downsample data to 250 Hz
thisNode = resample.new('OutputRate', 250);
nodeList = [nodeList {thisNode}];

% Node: band-pass filtering
myFilter = filter.bpfilt('fp', [1 100]/(250/2));
thisNode = tfilter.new('Filter', myFilter);
nodeList = [nodeList {thisNode}];

% The actual pipeline
myPipe = pipeline.new(...
    'NodeList',         nodeList, ...
    'Save',             true,  ...
    'GenerateReport',   DO_REPORT, ...
    'Name',             PIPE_NAME);

%% Process all relevant data files

% A regular expression that matches the names of all the files that we want
% to process at this stage
regex = '\.mff$';
files = finddepth_regex_match(INPUT_DIR, regex);
% link2files works only under Mac OS X and Linux
link2files(files, OUTPUT_DIR);
files = finddepth_regex_match(OUTPUT_DIR, regex);

data = run(myPipe, files{:});