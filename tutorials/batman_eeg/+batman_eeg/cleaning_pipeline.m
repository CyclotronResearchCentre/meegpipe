function myPipe = cleaning_pipeline(varargin)

import meegpipe.*;

import pset.selector.sensor_class;
import pset.selector.cascade;
import pset.selector.good_data;

USE_OGE = true;
DO_REPORT = true;
QUEUE = 'short.q@somerenserver.herseninstituut.knaw.nl';

nodeList = {};

%% Import
myImporter = physioset.import.physioset;
myNode = node.physioset_import.new('Importer', myImporter);
nodeList = [nodeList {myNode}];

%% copy data
myNode = node.copy.new;
nodeList = [nodeList {myNode}];

%% Node: remove large signal fluctuations using a LASIP filter

% Setting the "right" parameters of the filter involves quite a bit of
% trial and error. These values seemed OK to me but we should check
% carefully the reports to be sure that nothing went terribly wrong. In
% particular you should ensure that the LASIP filter is not removing
% valuable signal. It is OK if some residual noise is left after the LASIP
% filter so better to be conservative here.
myScales =  [20, 29, 42, 60, 87, 100, 126, 140, 182, 215, 264, 310, 382];

myFilter = filter.lasip(...
    'Decimation',       12, ...
    'GetNoise',         true, ... % Retrieve the filtering residuals
    'Gamma',            15, ...
    'Scales',           myScales, ...
    'WindowType',       {'Gaussian'}, ...
    'VarTh',            0.1);

% This object especifies which subset of data should be processed by the
% node. In this case we want to process only the EEG data, and ignore any
% other modalities.
mySel = pset.selector.sensor_class('Class', 'EEG');

myNode = node.filter.new(...
    'Filter',           myFilter, ...
    'Name',             'lasip', ...
    'DataSelector',     mySel, ...
    'ShowDiffReport',   true ...
    );

nodeList = [nodeList {myNode}];

%% bad channel rejection (using variance)
minVal = @(x) median(x) - 35;
maxVal = @(x) median(x) + 12;
myCrit = node.bad_channels.criterion.var.new('Min', minVal, 'Max', maxVal);
myNode = node.bad_channels.new('Criterion', myCrit);
nodeList = [nodeList {myNode}];

%% bad epochs
myNode = node.bad_epochs.sliding_window(1, 2, ...
    'Max',          @(x) median(x) + 3*mad(x));
nodeList = [nodeList {myNode}];

%% LP filter
mySel =  cascade(...
    sensor_class('Class', 'EEG'), ...
    good_data ...
    );
myNode = node.filter.new(...
    'Filter',       @(sr) filter.bpfilt('Fp', [1 70]/(sr/2)), ...
    'DataSelector', mySel, ...
    'Name',         'BP-filter-1-70Hz');
nodeList = [nodeList {myNode}];

%% Node: Downsample
myNode = node.resample.new('OutputRate', 250);
nodeList = [nodeList {myNode}];

%% Node: remove PWL noise
myNode = aar.pwl.new('IOReport', report.plotter.io);
nodeList = [nodeList {myNode}];

%% Node: remove MUX noise

% MUX noise seems to appear only very rarely. Seems the purpose of this
% node is to reject only that type of noise, we set the Max threshold to a
% very large value to try to remove only true MUX-related components.
mySel = cascade(sensor_class('Class', 'EEG'), good_data);
myFeat = spt.feature.psd_ratio(...
    'TargetBand',   [12 16;49 51;17 19], ...
    'RefBand',      [7 10]);

myCrit = spt.criterion.threshold(...
    'Feature',  myFeat, ...
    'Max',      @(x) min(median(x) + 4*mad(x), 100), ...
    'MaxCard',  2);

myPCA  = spt.pca(...
    'RetainedVar',99.85, ...
    'LearningFilter', @(sr) filter.lpfilt('Fc', 15/(sr/2)), ...
    'MaxCard',    15, ...
    'MinCard',    35);
myNode = node.bss.new(...
    'DataSelector',     mySel, ...
    'Criterion',        myCrit, ...
    'PCA',              myPCA, ...
    'BSS',              spt.bss.efica, ...
    'Name',             'mux-noise', ...
    'IOReport',         report.plotter.io);

nodeList = [nodeList {myNode}];

%% Node: Reject EOG components using their topography
myNode = aar.eog.topo_egi256_hcgsn1(...
    'RetainedVar',  99.85, ...
    'MinCard',      2, ...
    'MaxCard',      10, ...
    'IOReport',     report.plotter.io);
nodeList = [nodeList {myNode}];

%% Node: ECG
myNode = aar.ecg.new;
nodeList = [nodeList {myNode}];

%% low-pass filter
myNode = node.filter.new(...
    'Filter', @(sr) filter.lpfilt('Fc', 42/(sr/2)), ...
     'DataSelector', mySel, ...
    'Name', 'LP-filter-42Hz');
nodeList = [nodeList {myNode}];

%% Node: EMG correction
myNode = node.bss.emg(...
    'CorrectionTh',     50, ...
    'WindowLength',     10, ...
    'WindowOverlap',    75, ...
    'ShowDiffReport',   true, ...
    'IOReport',         report.plotter.io);
nodeList = [nodeList {myNode}];

%% supervised BSS
myNode = aar.bss_supervised;
nodeList = [nodeList {myNode}];


%% Pipeline
myPipe = node.pipeline.new(...
    'NodeList',         nodeList, ...
    'Save',             true, ...
    'Parallelize',      USE_OGE, ...
    'GenerateReport',   DO_REPORT, ...
    'Name',             'cleaning_pipe', ...
    'Queue',            QUEUE, ...
    varargin{:} ...
    );

